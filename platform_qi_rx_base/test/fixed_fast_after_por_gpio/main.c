/***************************************************************************//**
 * @file main.c
 * @brief This project demonstrates DMA-driven use of the USART in synchronous
 * (SPI) master mode. The main loop starts the LDMA channels, which transmit the
 * specified number of bytes and receive the byte that is shifted in with each
 * outgoing one.
 *
 * The pins used in this example are defined below and are described in the
 * accompanying readme.txt file.
 *******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 *******************************************************************************
 *
 * SPDX-License-Identifier: Zlib
 *
 * The licensor of this software is Silicon Laboratories Inc.
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 *
 *******************************************************************************
 * # Evaluation Quality
 * This code has been minimally tested to ensure that it builds and is suitable
 * as a demonstration for evaluation purposes only. This code will be maintained
 * at the sole discretion of Silicon Labs.
 ******************************************************************************/

#include "em_device.h"
#include "em_chip.h"
#include "em_cmu.h"
#include "em_emu.h"
#include "em_gpio.h"
#include "em_ldma.h"
#include "em_usart.h"
#include "em_prs.h"

// -----------------------------------------------------------------------------
//                                   Defines
// -----------------------------------------------------------------------------

// Ports and pins for SPI interface
#define US2MOSI_PORT              gpioPortC
#define US2MOSI_PIN               0

// Ports and pins for BTN0
#define BSP_GPIO_PB0_PORT         gpioPortB
#define BSP_GPIO_PB0_PIN          0

// Define to enable some debug signals during development for normal operation
// only the MOSI output of the SPI peripheral is needed.
// With DEBUG signals enabled also the CS and CLK of the PSI are routed to pins
// so e.g. an SPI analyzer can decode the bytes sent.
#define ENABLE_DEBUG_SIGNALS      0

#if (ENABLE_DEBUG_SIGNALS)
#define US2CLK_PORT               gpioPortC
#define US2CLK_PIN                2
#define US2CS_PORT                gpioPortC
#define US2CS_PIN                 3
#endif

// LDMA channel for transmit servicing
#define TX_INIT_LDMA_CHANNEL      0
#define TX_INIT_LDMA_CHANNEL_MASK (1 << TX_INIT_LDMA_CHANNEL)

// set PRS channel to use for Tx LDMA sync triggering
#define GPIO_PRS_CHANNEL          1

// -----------------------------------------------------------------------------
//                            Local variables
// -----------------------------------------------------------------------------
const uint32_t chmask = TX_INIT_LDMA_CHANNEL_MASK;
volatile bool qi_base_transfer_finished = false;

// This creates (an example of) fixed qi base protocol messages in flash
// generated by code in project.....

/******************************************************
* generated buffer for QI transmit over SPI, rev 0.1
******************************************************/
const uint8_t QI_init[] = {
  0xAA, 0xAA, 0xAB, 0x4C, 0xCC, 0xD2, 0xAA, 0xAA,
  0xB2, 0xAA, 0xAD, 0xFF, 0xFF, 0xFF, 0xFA, 0xAA,
  0xAA, 0xB4, 0xCA, 0xB5, 0x2C, 0xD3, 0x2B, 0x55,
  0x55, 0x52, 0xAA, 0xAA, 0xB5, 0x52, 0xAD, 0x2A,
  0xAA, 0xAB, 0x55, 0x55, 0x52, 0xAA, 0xAA, 0xB3,
  0x35, 0x4D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xAA, 0xAA, 0xAB, 0x4C, 0xB4, 0xD3, 0x4B,
  0x32, 0xB3, 0x33, 0x35, 0x33, 0x33, 0x2B, 0x2C,
  0xCB, 0x53, 0x33, 0x32, 0xB4, 0xD4, 0xCD
};

/******************************************************
* generated buffer for QI transmit over SPI, rev 0.1
******************************************************/
const uint8_t QI_control_error_PREDELAY[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xAA, 0xAB,
  0xF3, 0x73, 0x53, 0x33, 0xFA, 0xF5, 0x33, 0x35
};

#define QI_CONTROL_ERROR_MSG_REPEATCOUNT 5 // number of repeats after init

// -----------------------------------------------------------------------------
//                            Variable declarations
// -----------------------------------------------------------------------------

// LDMA descriptor and transfer configuration structures for USART TX channel
static const LDMA_Descriptor_t QI_Tx[] = {
  {
    .sync = {
      .structType = ldmaCtrlStructTypeSync,
      .structReq = 0,
      .xferCnt = 0,
      .byteSwap = 0,
      .blockSize = 0,
      .doneIfs = 0,
      .reqMode = 0,
      .decLoopCnt = 0,
      .ignoreSrec = 0,
      .srcInc = 0,
      .size = 0,
      .dstInc = 0,
      .srcAddrMode = 0,
      .dstAddrMode = 0,
      .syncSet = (0),
      .syncClr = (0),
      .matchVal = (0x02),
      .matchEn = (0x02),
      .linkMode = ldmaLinkModeRel,
      .link = 1,
      .linkAddr = (1) * 4
    }
  },
  {
    .xfer = {
      .structType = ldmaCtrlStructTypeXfer,
      .structReq = 0,
      .xferCnt = (sizeof(QI_init) / sizeof(uint8_t)) - 1,
      .byteSwap = 0,
      .blockSize = ldmaCtrlBlockSizeUnit1,
      .doneIfs = 0,
      .reqMode = ldmaCtrlReqModeBlock,
      .decLoopCnt = 0,
      .ignoreSrec = 0,
      .srcInc = ldmaCtrlSrcIncOne,
      .size = ldmaCtrlSizeByte,
      .dstInc = ldmaCtrlDstIncNone,
      .srcAddrMode = ldmaCtrlSrcAddrModeAbs,
      .dstAddrMode = ldmaCtrlDstAddrModeAbs,
      .srcAddr = (uint32_t) (QI_init),
      .dstAddr = (uint32_t) (&(((USART_TypeDef *) USART2_BASE)->TXDATA)),
      .linkMode = ldmaLinkModeRel,
      .link = 1,
      .linkAddr = 4 // point to next Descriptor in flash
    }
  },
  {
    .xfer = {
      .structType = ldmaCtrlStructTypeXfer,
      .structReq = 0,
      .xferCnt = (sizeof(QI_control_error_PREDELAY)
                  / sizeof(uint8_t)) - 1,
      .byteSwap = 0,
      .blockSize = ldmaCtrlBlockSizeUnit1,
      .doneIfs = 0,
      .reqMode = ldmaCtrlReqModeBlock,
      .decLoopCnt = 1,
      .ignoreSrec = 0,
      .srcInc = ldmaCtrlSrcIncOne,
      .size = ldmaCtrlSizeByte,
      .dstInc = ldmaCtrlDstIncNone,
      .srcAddrMode = ldmaCtrlSrcAddrModeAbs,
      .dstAddrMode = ldmaCtrlDstAddrModeAbs,
      .srcAddr = (uint32_t) (QI_control_error_PREDELAY),
      .dstAddr =
        (uint32_t) (&(((USART_TypeDef *) USART2_BASE)->TXDATA)),
      .linkMode = ldmaLinkModeRel,
      .link = 1,
      .linkAddr = 0
    }
  },
  {
    .sync = {
      .structType = ldmaCtrlStructTypeSync,
      .structReq = 0,
      .xferCnt = 0,
      .byteSwap = 0,
      .blockSize = 0,
      .doneIfs = 1,
      .reqMode = 0,
      .decLoopCnt = 0,
      .ignoreSrec = 0,
      .srcInc = 0,
      .size = 0,
      .dstInc = 0,
      .srcAddrMode = 0,
      .dstAddrMode = 0,
      .syncSet = (0x0),
      .syncClr = (0x02),
      .matchVal = (0),
      .matchEn = (0),
      .linkMode = 0,
      .link = 0,
      .linkAddr = 0
    }
  }
};

static const LDMA_TransferCfg_t ldmaTXConfig = {
  .ldmaReqSel = ldmaPeripheralSignal_USART2_TXBL,
  .ldmaCtrlSyncPrsClrOff = 0,
  .ldmaCtrlSyncPrsClrOn = 0,
  .ldmaCtrlSyncPrsSetOff = 0,
  .ldmaCtrlSyncPrsSetOn = 0,
  .ldmaReqDis = 0,
  .ldmaDbgHalt = 0,
  .ldmaCfgArbSlots = ldmaCfgArbSlotsAs1,
  .ldmaCfgSrcIncSign = ldmaCfgSrcIncSignPos,
  .ldmaCfgDstIncSign = ldmaCfgDstIncSignPos,
  .ldmaLoopCnt = QI_CONTROL_ERROR_MSG_REPEATCOUNT
};

/***************************************************************************//**
 * @brief
 *   Clock Initialization.
 ******************************************************************************/
static void init_cmu(void)
{
  // Initialize peripheral clocks
  CMU_ClockEnable(cmuClock_GPIO, true);
  CMU_ClockEnable(cmuClock_LDMA, true);
  CMU_ClockEnable(cmuClock_PRS, true);
  // Note: For EFRxG21 devices, library function calls to
  // CMU_ClockEnable() have no effect as oscillators are automatically turned
  // on/off based on demand from the peripherals; CMU_ClockEnable() is a dummy
  // function for EFR32xG21 for library consistency/compatibility.
}

/**************************************************************************//**
 * @brief
 *    GPIO initialization
 *****************************************************************************/
void init_prs_gpio(void)
{
  // Configure TX pin as an output
  GPIO_PinModeSet(US2MOSI_PORT, US2MOSI_PIN, gpioModePushPull, 0);

#if (ENABLE_DEBUG_SIGNALS)
  // Configure CLK pin as an output low (CPOL = 0)
  GPIO_PinModeSet(US2CLK_PORT, US2CLK_PIN, gpioModePushPull, 0);

  // Configure CS pin as an output and drive inactive high
  GPIO_PinModeSet(US2CS_PORT, US2CS_PIN, gpioModePushPull, 1);
#endif

  // Configure push button PB0 as input with pullup
  GPIO_PinModeSet(BSP_GPIO_PB0_PORT,
                  BSP_GPIO_PB0_PIN, gpioModeInputPullFilter, 1);

  // Configure PRS sensing on push button PB0
  GPIO_ExtIntConfig(BSP_GPIO_PB0_PORT, BSP_GPIO_PB0_PIN, BSP_GPIO_PB0_PIN,
                    false, false, false);

  // Select GPIO as PRS source and push button PB0 as signal for PRS channel
  PRS_SourceAsyncSignalSet(GPIO_PRS_CHANNEL, PRS_ASYNC_CH_CTRL_SOURCESEL_GPIO,
                           BSP_GPIO_PB0_PIN);

  // DMA request is high active, invert PRS signal to default low
  // PRS_Combine(GPIO_PRS_CHANNEL, GPIO_PRS_CHANNEL, prsLogic_NOT_A);
}

/**************************************************************************//**
 * @brief
 *    USART2 initialization
 *****************************************************************************/
void init_usart2(void)
{
  // Default asynchronous initializer (master mode, 1 Mbps, 8-bit data)
  USART_InitSync_TypeDef init = USART_INITSYNC_DEFAULT
  ;

  init.baudrate = 4000;       // set to 4kHz
  init.msbf = true;           // MSB first transmission for SPI compatibility
  init.autoCsEnable = true;   // Allow the USART to assert CS
  init.autoCsSetup = 0;       // Insert 7 bit times of CS setup delay
  init.autoCsHold = 0;        // Insert 7 bit times of CS hold delay

  // Route USART2 TX to the specified pin.
  GPIO->USARTROUTE[2].TXROUTE = (US2MOSI_PORT << _GPIO_USART_TXROUTE_PORT_SHIFT)
                                | (US2MOSI_PIN <<
                                   _GPIO_USART_TXROUTE_PIN_SHIFT);

#if (ENABLE_DEBUG_SIGNALS)
  // Route USART2 CS and CLK to the specified pins, for debugging only
  GPIO->USARTROUTE[2].CLKROUTE =
    (US2CLK_PORT << _GPIO_USART_CLKROUTE_PORT_SHIFT)
    | (US2CLK_PIN << _GPIO_USART_CLKROUTE_PIN_SHIFT);
  GPIO->USARTROUTE[2].CSROUTE = (US2CS_PORT << _GPIO_USART_CSROUTE_PORT_SHIFT)
                                | (US2CS_PIN << _GPIO_USART_CSROUTE_PIN_SHIFT);
#endif

  // Enable USART interface pin for MOSI (Tx output)
  GPIO->USARTROUTE[2].ROUTEEN = GPIO_USART_ROUTEEN_TXPEN;    // MOSI
#if (ENABLE_DEBUG_SIGNALS)
  // Enable USART interface pins for CS and clock
  GPIO->USARTROUTE[2].ROUTEEN |=
    GPIO_USART_ROUTEEN_CLKPEN
    | GPIO_USART_ROUTEEN_CSPEN;
#endif
  // Configure and enable USART2
  USART_InitSync(USART2, &init);
  USART_SpiTransfer(USART2, 0xFF); // make sure we start with Tx high
}

/**************************************************************************//**
 * @brief
 *    LDMA initialization
 *****************************************************************************/
void init_ldma(void)
{
  // First, initialize the LDMA unit itself
  const LDMA_Init_t ldmaInit = // LDMA_INIT_DEFAULT;
  {
    // Fixed priority arbitration.
    .ldmaInitCtrlNumFixed = _LDMA_CTRL_NUMFIXED_DEFAULT,
    // No PRS Synctrig clear enable
    .ldmaInitCtrlSyncPrsClrEn = 0,
    // PRS Synctrig set enable.
    .ldmaInitCtrlSyncPrsSetEn = (uint32_t) ((0x1) << GPIO_PRS_CHANNEL),
    // IRQ priority level 3.
    .ldmaInitIrqPriority = 3
  };
  LDMA_Init(&ldmaInit);
  // we need to clear LDMA_SYNCHbit as it may have been set by enabling PRS.
  LDMA->SYNCSWCLR = (uint32_t) ((0x1) << GPIO_PRS_CHANNEL);
}

/**************************************************************************//**
 * @brief LDMA IRQHandler
 *****************************************************************************/
void LDMA_IRQHandler()
{
  uint32_t ch;
  // Get all pending and enabled interrupts
  uint32_t pending = LDMA_IntGetEnabled();

  // break on an LDMA error to enable debugging
  if (pending & LDMA_IF_ERROR) {
    __BKPT(0);
  }

  // Iterate over all LDMA channels
  for (ch = 0; ch < DMA_CHAN_COUNT; ch++) {
    uint32_t mask = 0x1 << ch;
    if (pending & mask) {
      // Clear the interrupt flag
      LDMA_IntClear(mask);
      // Perform more actions here, execute callbacks, and so on
      switch (ch) {
        case 0: // the Qi tansfer is finished so re-start trigger
          qi_base_transfer_finished = true;
          break;

        default:
          __BKPT(0); // not expected so stop so we can inspect
      }
    }
  }
}

/**************************************************************************//**
 * @brief
 *    Main function
 *****************************************************************************/
int main(void)
{
  // Chip errata
  CHIP_Init();

  // Init DCDC regulator if available
#if defined(DCDC)
  EMU_DCDCInit_TypeDef dcdcInit = EMU_DCDCINIT_DEFAULT;
  EMU_DCDCInit(&dcdcInit);
#endif

  // Initialize clock
  init_cmu();

  // Initialize GPIO, USART and LDMA
  init_prs_gpio();
  init_usart2();
  init_ldma();

  // start QI DMA after POR
  LDMA_StartTransfer(TX_INIT_LDMA_CHANNEL, &ldmaTXConfig, &QI_Tx[1]);

  while (1) {
    if (qi_base_transfer_finished) {
      qi_base_transfer_finished = false;
      // now start QI DMA waiting for sync (from GPIO)
      LDMA_StartTransfer(TX_INIT_LDMA_CHANNEL, &ldmaTXConfig, &QI_Tx[0]);
    }
    EMU_EnterEM1();
  }

  // we should never end here when we have done everything right
  __BKPT(0);
}
