# xG22 Asynchronous EM01GRPA Clock Output #
![Type badge](https://img.shields.io/badge/dynamic/json?url=https://raw.githubusercontent.com/SiliconLabs/application_examples_ci/master/platform_applications/platform_async_em01grpaclk_out_series2_common.json&label=Type&query=type&color=green)
![Technology badge](https://img.shields.io/badge/dynamic/json?url=https://raw.githubusercontent.com/SiliconLabs/application_examples_ci/master/platform_applications/platform_async_em01grpaclk_out_series2_common.json&label=Technology&query=technology&color=green)
![License badge](https://img.shields.io/badge/dynamic/json?url=https://raw.githubusercontent.com/SiliconLabs/application_examples_ci/master/platform_applications/platform_async_em01grpaclk_out_series2_common.json&label=License&query=license&color=green)
![SDK badge](https://img.shields.io/badge/dynamic/json?url=https://raw.githubusercontent.com/SiliconLabs/application_examples_ci/master/platform_applications/platform_async_em01grpaclk_out_series2_common.json&label=SDK&query=sdk&color=green)
![Build badge](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/SiliconLabs/application_examples_ci/master/platform_applications/platform_async_em01grpaclk_out_series2_build_status.json)
![Flash badge](https://img.shields.io/badge/dynamic/json?url=https://raw.githubusercontent.com/SiliconLabs/application_examples_ci/master/platform_applications/platform_async_em01grpaclk_out_series2_common.json&label=Flash&query=flash&color=blue)
![RAM badge](https://img.shields.io/badge/dynamic/json?url=https://raw.githubusercontent.com/SiliconLabs/application_examples_ci/master/platform_applications/platform_async_em01grpaclk_out_series2_common.json&label=RAM&query=ram&color=blue)

## Summary ##

This example drives a 50% duty cycle 6 MHz clock generated by TIMER0
on PA6 (expansion header pin 14). The DPLL is set to run at 36 MHz for
this purpose. By default, the EM01GRPACLK is sourced from the DPLL and
certain peripherals also either run from or default to this clock,
namely the TIMERs, EUART, and IADC.

Modules used: CMU, EMU, GPIO, and TIMER0.

## Gecko SDK version ##

v2.7.x

## Hardware Required ##

* Wireless Starter Kit (WSTK) Mainboard (SLWMB4001A / BRD4001A)
* EFR32xG22 2.4 GHz 6 dBm Radio Board (SLWRB4182A / BRD4182A)

## Setup ##

Clone the repository with this project from GitHub onto your local machine.

From within the Simplicity Studio IDE, select Import -> MCU Project...
from the Project menu. Click the Browse button and navigate to the
local repository folder, then to the SimplicityStudio folder, select
the .slsproj file for the board, click the Next button twice, and then
click Finish.

## How the Project Works ##

EFR32xG22 devices (and modules based on the EFR32xG22) have the ability
to run some parts of the system asynchronous to the SYSCLK, which is the
root high frequency clock from which all other high-frequency clocks are
or can be derived. A key benefit of this arrangement is that things like
the TIMERs or IADC can run at an application-specific frequency without
impacting the operation of radio, which must always be clocked from the
HFXO at 38.4 MHz.

The idea behind this particular example was a customer requirement to
provide a 6 MHz CMOS clock output that could serve as the clock source
for a companion MCU to the EFR32BG22C112, a cost-optimized member of
the EFR32xG22 family that is limited to operation at at maximum of 38.4 MHz.

It would be a simple matter to generate 6 MHz with the DPLL and output
this directly to one of the three CMU_CLKOUT[2:0] outputs via the
relevant bit fields in the CMU_EXPORTCLKCTRL and GPIO_CMU_CLKOUTnROUTE
control registers.

However, the downside of doing this is that there is no way to control
the state of the DPLL-driven clock output. When the EFR32xG22 enters
EM2, the selected CMU_CLKOUTn stops. Upon exit from EM2, CMU_CLKOUTn
drives the unstable output of the DPLL without qualification, and this
might be problematic for whatever device needs to use it as a clock.

Using a TIMER to generate the clock has the distinct advantage of
providing a software mechanism to not only start and stop the clock
but to stop it in a known state. This is particularly important when
using the clock for an external processor as stopping/restarting the
clock in an unknown state (or out of specification as could happen
if the HFRCODPLL output is used directly) might lead to incorrect
operation of the device. 

The code flow is as follows:

1. Initialize clocks.

This is where the DPLL is configured tun run at some multiple of the
desired clock output frequency. The HFXO is started first, as it is
selected as the source of the SYSCLK and also used as the reference
for the DPLL.

2. Initialize push button 0.

The GPIO for the pin connected to push button 0 is initalized and
configured to generate interrupt requests on rising edges.

3. Initialize TIMER0.

As EM01GRPACLK is the clock for all TIMERs, it is only necessary to
setup one timer capture/compare channel (TIMER0 and CC0, in this case)
to run in PWM mode and toggle at half the top count value in order to
generate a 50% duty cycle output.

The global clockState variable of type OutputClock_TypeDef specifies
the desired frequency, the off state, and whether the clock is running
or not. The variable also tracks the values written to the TIMER_TOP
and TIMER_CC0_OC registers. These are determined in the initialization
function based on the requested output frequency and do not need to be
set by the user.

4. Wait in EM1 to allow the clock output to be observed on PA6 (WSTK expansion header pin 14).

While waiting in EM1 (or running in EM0), the EM01GRPACLK is active, so
TIMER0 runs. Pressing button 0 transfers execution to the enabled GPIO
interrupt handler where the the clock output is stopped by writing 0 to
the buffered output compare register. This allows the TIMER to stop
with its output in the specified off state. In a real application, some
kind of handshaking function might be used to negotiate stopping the
clock or even shifting to a higher or lower frequency. Upon exiting the
interrupt handler, the system enters EM2.

5. Wait in EM2 to allow the stopped clock output to be observed.

The EM01GRPACLK remains stopped in EM2 while the system again waits for
a rising edge on the button 0 GPIO pin. That edge causes the system to
exit EM2, and the interrupt handler writes the predetermined value to
TIMER_CC0_OCB, effectively restarting the clock by causing a match and
output toggle at the 50% duty cycle count. Upon exit from the IRQ
handler, the code returns to the main while loop and step #4 above.

## Porting to Another EFR32 Series 2 Device ##

Apart from any issues of pin availability on a given radio board, this
code should run as-is on any radio board for EFR32xG22 or any module
that is based on EFR32xG22, such as BGM220P and BGM220S.

The code can also run on EFR32xG21, although this has not been tested.
Because it has on-demand enabling of module register clocks, the
individual CMU_ClockEnable() calls are not necessary on EFR32xG21,
although they will have no effect other than to waste CPU cycles if
left in place.

To change the target board, navigate to Project -> Properties -> C/C++ Build -> Board/Part/SDK. Start typing in the Boards
search box and locate the desired radio board, then click Apply to change the project settings, and go from there.